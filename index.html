<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drone Show K·ª∑ Ni·ªám 2 NƒÉm - TH√ôY D∆Ø∆†NG</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
        #startBtn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            padding: 12px 24px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 30px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 16px;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
        }
        #startBtn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <audio src="voice.mp3" type="audio/mp3" controls>
        
    </audio>
    <div id="loading">ƒêang t·∫£i h√¨nh ·∫£nh ch√¢n dung...</div>
    <button id="startBtn">üåü B·∫Øt ƒê·∫ßu Tr√¨nh Di·ªÖn</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <script>
        // Kh·ªüi t·∫°o scene, camera v√† renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Thi·∫øt l·∫≠p camera
        camera.position.z = 300;
        camera.lookAt(0, 0, 0);
        
        // T·∫°o 10.000 ƒëi·ªÉm s√°ng
        const droneCount = 10000;
        const droneGeometry = new THREE.BufferGeometry();
        const droneMaterial = new THREE.PointsMaterial({
            color: 0xff3366,
            size: 3,
            sizeAttenuation: false,
            transparent: true,
            opacity: 0.95,
            blending: THREE.AdditiveBlending
        });
        
        // L∆∞u tr·ªØ v·ªã tr√≠ ban ƒë·∫ßu
        const initialPositions = new Float32Array(droneCount * 3);
        for (let i = 0; i < droneCount; i++) {
            initialPositions[i * 3] = (Math.random() - 0.5) * 200;
            initialPositions[i * 3 + 1] = (Math.random() - 0.5) * 200;
            initialPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;
        }
        
        const positions = new Float32Array(initialPositions);
        droneGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const drones = new THREE.Points(droneGeometry, droneMaterial);
        scene.add(drones);

        // T·∫°o c√°c h·∫°t ph√°o hoa tr√°i tim
        const heartFireworks = new THREE.Group();
        scene.add(heartFireworks);
        
        // Bi·∫øn l∆∞u tr·ªØ v·ªã tr√≠ ch√¢n dung
        let portraitPositions = [];
        
        // H√†m t·∫°o v·ªã tr√≠ t·ª´ h√¨nh ·∫£nh ch√¢n dung
        function createPortraitPositions(imageUrl, callback) {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = imageUrl;
            
            img.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // ƒêi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc ƒë·ªÉ ph√π h·ª£p v·ªõi s·ªë l∆∞·ª£ng drone
                const maxWidth = 200;
                const maxHeight = 250;
                let width = img.width;
                let height = img.height;
                
                if (width > height) {
                    if (width > maxWidth) {
                        height *= maxWidth / width;
                        width = maxWidth;
                    }
                } else {
                    if (height > maxHeight) {
                        width *= maxHeight / height;
                        height = maxHeight;
                    }
                }
                
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                const positions = [];
                
                // L·∫•y c√°c ƒëi·ªÉm ·∫£nh quan tr·ªçng
                const step = 2;
                const minBrightness = 50; // Ng∆∞·ª°ng s√°ng t·ªëi thi·ªÉu
                
                for (let y = 0; y < height; y += step) {
                    for (let x = 0; x < width; x += step) {
                        const idx = (y * width + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        
                        // T√≠nh ƒë·ªô s√°ng
                        const brightness = (r + g + b) / 3;
                        
                        if (brightness > minBrightness) {
                            // Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô ƒë·ªÉ cƒÉn gi·ªØa
                            const xPos = (x - width/2) * 1.5;
                            const yPos = -(y - height/2) * 1.5;
                            
                            positions.push(xPos, yPos, 0);
                        }
                    }
                }
                
                // N·∫øu kh√¥ng ƒë·ªß ƒëi·ªÉm, th√™m c√°c ƒëi·ªÉm ng·∫´u nhi√™n t·ª´ ·∫£nh
                if (positions.length / 3 < droneCount / 2) {
                    const neededPoints = droneCount - positions.length / 3;
                    for (let i = 0; i < neededPoints; i++) {
                        const x = Math.floor(Math.random() * width);
                        const y = Math.floor(Math.random() * height);
                        const idx = (y * width + x) * 4;
                        
                        if (data[idx] > minBrightness || 
                            data[idx+1] > minBrightness || 
                            data[idx+2] > minBrightness) {
                            const xPos = (x - width/2) * 1.5;
                            const yPos = -(y - height/2) * 1.5;
                            positions.push(xPos, yPos, 0);
                        }
                    }
                }
                
                callback(positions);
            };
            
            img.onerror = function() {
                console.error("Kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh ch√¢n dung");
                // N·∫øu kh√¥ng t·∫£i ƒë∆∞·ª£c ·∫£nh, t·∫°o m·ªôt h√¨nh tr√°i tim thay th·∫ø
                callback(createHeartPositions());
            };
        }
        
        // T·∫£i h√¨nh ·∫£nh ch√¢n dung
        createPortraitPositions("https://i.postimg.cc/L8tp7cbk/cd9df89c-47da-46f9-ac20-8f471b5e9109.jpg", function(positions) {
            portraitPositions = positions;
            document.getElementById('loading').style.display = 'none';
        });
        
        // T·∫°o v·ªã tr√≠ cho ch·ªØ ANH Y√äU EM
        function createTextPositions() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 2500;
            canvas.height = 800;
            
            ctx.font = "Bold 220px 'Arial Black', sans-serif";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.textRendering = "geometricPrecision";
            
            ctx.strokeStyle = "white";
            ctx.lineWidth = 20;
            ctx.strokeText("ANH Y√äU EM", canvas.width/2, canvas.height/2);
            ctx.fillText("ANH Y√äU EM", canvas.width/2, canvas.height/2);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const positions = [];
            
            const pixelMap = {};
            const step = 2;
            
            for (let y = 0; y < canvas.height; y += step) {
                for (let x = 0; x < canvas.width; x += step) {
                    const idx = (y * canvas.width + x) * 4;
                    if (data[idx] > 0) {
                        const xPos = Math.round((x - canvas.width/2) * 0.12);
                        const yPos = Math.round(-(y - canvas.height/2) * 0.12);
                        const key = `${xPos},${yPos}`;
                        
                        if (!pixelMap[key]) {
                            pixelMap[key] = true;
                            positions.push(xPos, yPos, 0);
                        }
                    }
                }
            }
            return positions;
        }
        
        // T·∫°o v·ªã tr√≠ cho ch·ªØ TH√ôY D∆Ø∆†NG
        function createThuyDuongPositions() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 2500;
            canvas.height = 800;
            
            ctx.font = "Bold 220px 'Arial Black', sans-serif";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.textRendering = "geometricPrecision";
            
            ctx.strokeStyle = "white";
            ctx.lineWidth = 20;
            ctx.strokeText("TH√ôY D∆Ø∆†NG", canvas.width/2, canvas.height/2);
            ctx.fillText("TH√ôY D∆Ø∆†NG", canvas.width/2, canvas.height/2);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const positions = [];
            
            const pixelMap = {};
            const step = 2;
            
            for (let y = 0; y < canvas.height; y += step) {
                for (let x = 0; x < canvas.width; x += step) {
                    const idx = (y * canvas.width + x) * 4;
                    if (data[idx] > 0) {
                        const xPos = Math.round((x - canvas.width/2) * 0.12);
                        const yPos = Math.round(-(y - canvas.height/2) * 0.12);
                        const key = `${xPos},${yPos}`;
                        
                        if (!pixelMap[key]) {
                            pixelMap[key] = true;
                            positions.push(xPos, yPos, 0);
                        }
                    }
                }
            }
            return positions;
        }
        
        // T·∫°o v·ªã tr√≠ cho h√¨nh tr√°i tim l·ªõn
        function createHeartPositions() {
            const positions = [];
            const scale = 100;
            const density = 0.6;
            
            for (let t = 0; t < 2 * Math.PI; t += 0.01 * density) {
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                
                positions.push(x * scale * 0.1, -y * scale * 0.1, 0);
                
                for (let r = 0.3; r < 0.9; r += 0.2 * density) {
                    positions.push(x * scale * 0.1 * r, -y * scale * 0.1 * r, 0);
                }
            }
            
            for (let i = 0; i < 3000; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.sqrt(Math.random()) * 0.8;
                
                const x = 16 * Math.pow(Math.sin(angle), 3);
                const y = (13 * Math.cos(angle) - 5 * Math.cos(2*angle) - 2 * Math.cos(3*angle) - Math.cos(4*angle)) * radius;
                
                positions.push(x * scale * 0.1, -y * scale * 0.1, 0);
            }
            
            return positions;
        }
        
        // T·∫°o v·ªã tr√≠ cho nhi·ªÅu tr√°i tim nh·ªè bay l√™n
        function createFlyingHearts() {
            const hearts = [];
            const heartSize = 15;
            
            for (let i = 0; i < droneCount; i++) {
                const x = (Math.random() - 0.5) * 200;
                const y = (Math.random() - 0.5) * 200;
                const t = Math.random() * 2 * Math.PI;
                const heart = [];
                
                for (let j = 0; j < 10; j++) {
                    const angle = t + j * 0.2;
                    const xPos = 16 * Math.pow(Math.sin(angle), 3);
                    const yPos = 13 * Math.cos(angle) - 5 * Math.cos(2*angle) - 2 * Math.cos(3*angle) - Math.cos(4*angle);
                    
                    heart.push(
                        x + xPos * heartSize * 0.1,
                        y + yPos * heartSize * 0.1,
                        0
                    );
                }
                
                hearts.push(...heart);
            }
            
            return hearts;
        }
        
        // T·∫°o v·ªã tr√≠ cho c√°c v√¨ sao tr√™n b·∫ßu tr·ªùi
        function createStarPositions() {
            const positions = [];
            for (let i = 0; i < droneCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 2000,
                    Math.random() * 1000 + 300,
                    (Math.random() - 0.5) * 1000
                );
            }
            return positions;
        }
        
        // T·∫°o v·ªã tr√≠ cho ng√†y k·ªâ ni·ªám 05.08.2025
        function createDatePositions() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 3000;
            canvas.height = 1000;
            
            ctx.font = "Bold 300px 'Arial Black', sans-serif";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.textRendering = "geometricPrecision";
            
            ctx.strokeStyle = "white";
            ctx.lineWidth = 30;
            ctx.strokeText("05.08.2025", canvas.width/2, canvas.height/2);
            ctx.fillText("05.08.2025", canvas.width/2, canvas.height/2);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const positions = [];
            
            const pixelMap = {};
            const step = 2;
            
            for (let y = 0; y < canvas.height; y += step) {
                for (let x = 0; x < canvas.width; x += step) {
                    const idx = (y * canvas.width + x) * 4;
                    if (data[idx] > 0) {
                        const xPos = Math.round((x - canvas.width/2) * 0.15);
                        const yPos = Math.round(-(y - canvas.height/2) * 0.15);
                        const key = `${xPos},${yPos}`;
                        
                        if (!pixelMap[key]) {
                            pixelMap[key] = true;
                            positions.push(xPos, yPos, 0);
                        }
                    }
                }
            }
            return positions;
        }
        
        // T·∫°o v·ªã tr√≠ cho 1 b√¥ng hoa anh ƒë√†o duy nh·∫•t (phi√™n b·∫£n chi ti·∫øt)
        function createCherryBlossomPositions() {
            const positions = [];
            const scale = 40;
            const petalCount = 5;
            
            // T·∫°o nh·ª•y hoa (m√†u v√†ng)
            for (let j = 0; j < 150; j++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * scale * 0.4;
                positions.push(
                    radius * Math.cos(angle),
                    radius * Math.sin(angle),
                    0
                );
            }
            
            // T·∫°o 5 c√°nh hoa
            for (let i = 0; i < petalCount; i++) {
                const angle = (i * 2 * Math.PI) / petalCount;
                
                // H√¨nh d·∫°ng c√°nh hoa ph·ª©c t·∫°p h∆°n
                for (let t = 0; t < Math.PI * 2; t += 0.03) {
                    const r = scale * (0.7 + 0.3 * Math.sin(t * 5));
                    const x = r * Math.cos(t);
                    const y = r * (0.5 + 0.5 * Math.sin(t)) * Math.sin(t);
                    
                    // Xoay c√°nh hoa
                    const rotatedX = x * Math.cos(angle) - y * Math.sin(angle);
                    const rotatedY = x * Math.sin(angle) + y * Math.cos(angle);
                    
                    // Th√™m c√°c ƒëi·ªÉm ·ªü gi·ªØa c√°nh hoa (m√†u ƒë·∫≠m h∆°n)
                    for (let k = 0; k < 3; k++) {
                        const ratio = k * 0.3;
                        positions.push(
                            rotatedX * ratio,
                            rotatedY * ratio,
                            0
                        );
                    }
                    
                    // Th√™m ƒëi·ªÉm ·ªü r√¨a c√°nh hoa
                    positions.push(
                        rotatedX,
                        rotatedY,
                        0
                    );
                }
            }
            
            // Th√™m c√°c c√°nh hoa r∆°i xung quanh
            for (let p = 0; p < 15; p++) {
                const petalAngle = Math.random() * Math.PI * 2;
                const petalDistance = scale * (1.5 + Math.random() * 2);
                const petalX = petalDistance * Math.cos(petalAngle);
                const petalY = petalDistance * Math.sin(petalAngle);
                
                for (let t = 0; t < Math.PI * 2; t += 0.3) {
                    const r = scale * 0.4 * (0.7 + 0.3 * Math.sin(t * 5));
                    const x = r * Math.cos(t);
                    const y = r * (0.5 + 0.5 * Math.sin(t)) * Math.sin(t);
                    
                    positions.push(
                        petalX + x,
                        petalY + y,
                        0
                    );
                }
            }
            
            return positions;
        }
        
        // T·∫°o v·ªã tr√≠ cho tr√°i tim r∆°i t·ª´ tr√™n xu·ªëng
        function createFallingHearts() {
            const positions = [];
            const heartCount = 50;
            const heartSize = 10;
            
            for (let h = 0; h < heartCount; h++) {
                const startX = (Math.random() - 0.5) * 300;
                const startY = 300 + Math.random() * 100;
                
                for (let t = 0; t < 2 * Math.PI; t += 0.2) {
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    
                    positions.push(
                        startX + x * heartSize * 0.1,
                        startY + y * heartSize * 0.1,
                        0
                    );
                }
            }
            
            return positions;
        }
        
        // T·∫°o tr√°i tim bay t·ª´ vi·ªÅn m√†n h√¨nh (phi√™n b·∫£n ƒë∆°n gi·∫£n)
        function createHeartsFromEdges() {
            const heartCount = 10000;
            const duration = 15; // Th·ªùi gian bay
            
            // T√≠nh to√°n k√≠ch th∆∞·ªõc m√†n h√¨nh
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const margin = 50;
            
            // T·∫°o geometry cho Points
            const positions = new Float32Array(heartCount * 3);
            const colors = new Float32Array(heartCount * 3);
            const sizes = new Float32Array(heartCount);
            
            // M√†u s·∫Øc (h·ªìng)
            const color = new THREE.Color(0xff3366);
            
            // T·∫°o d·ªØ li·ªáu ban ƒë·∫ßu
            for (let i = 0; i < heartCount; i++) {
                // V·ªã tr√≠ b·∫Øt ƒë·∫ßu t·ª´ vi·ªÅn m√†n h√¨nh
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.max(screenWidth, screenHeight) / 2 + 50;
                
                positions[i*3] = Math.cos(angle) * radius;
                positions[i*3+1] = Math.sin(angle) * radius;
                positions[i*3+2] = 0; // Z position
                
                // M√†u s·∫Øc
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;
                
                // K√≠ch th∆∞·ªõc
                sizes[i] = 2 + Math.random() * 2;
            }
            
            // T·∫°o geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // T·∫°o material
            const material = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: false
            });
            
            // T·∫°o points
            const hearts = new THREE.Points(geometry, material);
            scene.add(hearts);
            
            // T·∫°o animation bay ch·∫≠m v√†o trung t√¢m
            for (let i = 0; i < heartCount; i++) {
                const targetX = (Math.random() - 0.5) * 100;
                const targetY = (Math.random() - 0.5) * 50;
                
                gsap.to(positions, {
                    [i*3]: targetX,
                    [i*3+1]: targetY,
                    duration: duration,
                    delay: Math.random() * 3, // ƒê·ªô tr·ªÖ ng·∫´u nhi√™n
                    ease: "sine.inOut",
                    onUpdate: () => {
                        geometry.attributes.position.needsUpdate = true;
                    }
                });
            }
            
            // T·ª± ƒë·ªông x√≥a sau khi ho√†n th√†nh
            setTimeout(() => {
                scene.remove(hearts);
                geometry.dispose();
                material.dispose();
            }, (duration + 5) * 1000);
        }
        
        // X·ª≠ l√Ω n√∫t b·∫•m
        document.getElementById('startBtn').addEventListener('click', () => {
            startShow();
        });
        
        // Di chuy·ªÉn drone ƒë·∫øn v·ªã tr√≠ m·ª•c ti√™u v√† x·ª≠ l√Ω drone th·ª´a
        function moveDronesToPositions(targetPositions, duration = 3, delayFactor = 2) {
            const positions = droneGeometry.attributes.position.array;
            const usedIndices = new Set();
            
            // Di chuy·ªÉn drone ƒë·∫øn v·ªã tr√≠ m·ª•c ti√™u
            for (let i = 0; i < targetPositions.length / 3; i++) {
                const tx = targetPositions[i*3];
                const ty = targetPositions[i*3+1];
                const tz = targetPositions[i*3+2];
                
                let closestIndex = -1;
                let minDistance = Infinity;
                
                for (let j = 0; j < droneCount; j++) {
                    if (usedIndices.has(j)) continue;
                    
                    const dx = positions[j*3] - tx;
                    const dy = positions[j*3+1] - ty;
                    const distance = dx*dx + dy*dy;
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = j;
                    }
                }
                
                if (closestIndex >= 0) {
                    usedIndices.add(closestIndex);
                    const delay = Math.sqrt(i / (targetPositions.length/3)) * delayFactor;
                    
                    gsap.to(positions, {
                        [closestIndex*3]: tx,
                        [closestIndex*3+1]: ty,
                        [closestIndex*3+2]: tz,
                        duration: duration,
                        delay: delay,
                        ease: "power2.out"
                    });
                }
            }
            
            // X·ª≠ l√Ω c√°c drone th·ª´a - cho bay ra kh·ªèi m√†n h√¨nh
            for (let i = 0; i < droneCount; i++) {
                if (!usedIndices.has(i)) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 1000;
                    const targetX = Math.cos(angle) * distance;
                    const targetY = Math.sin(angle) * distance;
                    
                    gsap.to(positions, {
                        [i*3]: targetX,
                        [i*3+1]: targetY,
                        duration: duration,
                        delay: Math.random() * delayFactor,
                        ease: "power2.out"
                    });
                }
            }
            
            gsap.ticker.add(() => {
                droneGeometry.attributes.position.needsUpdate = true;
            });
        }
        
        // Chuy·ªÉn ƒë·ªông h·ªón lo·∫°n
        function startChaosMovement() {
            const positions = droneGeometry.attributes.position.array;
            
            for (let i = 0; i < droneCount; i++) {
                gsap.to(positions, {
                    [i * 3]: (Math.random() - 0.5) * 200,
                    [i * 3 + 1]: (Math.random() - 0.5) * 200,
                    [i * 3 + 2]: (Math.random() - 0.5) * 200,
                    duration: 3,
                    delay: Math.random() * 2,
                    ease: "power2.out"
                });
            }
            
            gsap.to(droneMaterial, {
                color: new THREE.Color(Math.random() * 0xffffff),
                duration: 2
            });
        }
        
        // Hi·ªáu ·ª©ng tr√°i tim bay l√™n
        function startHeartsFlying() {
            const positions = droneGeometry.attributes.position.array;
            moveDronesToPositions(createFlyingHearts(), 2, 1);
            
            setTimeout(() => {
                for (let i = 0; i < droneCount; i++) {
                    gsap.to(positions, {
                        [i * 3 + 1]: positions[i * 3 + 1] + 500,
                        [i * 3 + 2]: (Math.random() - 0.5) * 100,
                        duration: 5 + Math.random() * 3,
                        delay: Math.random() * 2,
                        ease: "power1.out",
                        onComplete: () => {
                            positions[i * 3 + 1] = -300;
                            droneGeometry.attributes.position.needsUpdate = true;
                        }
                    });
                }
                
                gsap.to(droneMaterial, {
                    color: new THREE.Color(0xffb6c1),
                    duration: 2
                });
            }, 2000);
        }
        
        // Hi·ªáu ·ª©ng bay l√™n tr·ªùi t·∫°o th√†nh c√°c v√¨ sao
        function flyToStars() {
            const positions = droneGeometry.attributes.position.array;
            
            for (let i = 0; i < droneCount; i++) {
                gsap.to(positions, {
                    [i * 3 + 1]: positions[i * 3 + 1] + 500,
                    [i * 3 + 2]: (Math.random() - 0.5) * 500,
                    duration: 5 + Math.random() * 3,
                    delay: Math.random() * 2,
                    ease: "power1.out"
                });
            }
            
            setTimeout(() => {
                moveDronesToPositions(createStarPositions(), 4, 1);
                
                gsap.to(droneMaterial, {
                    color: new THREE.Color(0xffffff),
                    size: 1.5,
                    duration: 3
                });
                
                setTimeout(() => {
                    setInterval(() => {
                        gsap.to(droneMaterial, {
                            color: new THREE.Color(Math.random() > 0.5 ? 0xffffff : 0xffff99),
                            duration: 0.5 + Math.random()
                        });
                    }, 1000);
                }, 3000);
            }, 5000);
        }
        
        // Hi·ªáu ·ª©ng ch·ªØ Th√πy D∆∞∆°ng r∆°i xu·ªëng
        function thuyDuongFalling() {
            flyToStars();
            
            setTimeout(() => {
                const thuyDuongPositions = createThuyDuongPositions();
                const targetPositions = [];
                
                for (let i = 0; i < thuyDuongPositions.length / 3; i++) {
                    targetPositions.push(
                        thuyDuongPositions[i*3],
                        thuyDuongPositions[i*3+1] + 500,
                        thuyDuongPositions[i*3+2]
                    );
                }
                
                moveDronesToPositions(targetPositions, 3, 1);
                
                setTimeout(() => {
                    moveDronesToPositions(thuyDuongPositions, 2, 0);
                    
                    gsap.to(droneMaterial, {
                        color: new THREE.Color(0xffcc00),
                        size: 4,
                        duration: 2
                    });
                    
                    setTimeout(startFallingHearts, 5000);
                }, 3000);
            }, 10000);
        }
        
        // Hi·ªáu ·ª©ng tr√°i tim r∆°i t·ª´ tr√™n xu·ªëng
        function startFallingHearts() {
            startChaosMovement();
            
            setTimeout(() => {
                moveDronesToPositions(createFallingHearts(), 3, 1);
                
                gsap.to(droneMaterial, {
                    color: new THREE.Color(0xff3366),
                    size: 3,
                    duration: 2
                });
                
                const positions = droneGeometry.attributes.position.array;
                for (let i = 0; i < droneCount; i++) {
                    if (positions[i*3+1] > -200) {
                        gsap.to(positions, {
                            [i*3+1]: positions[i*3+1] - 300,
                            duration: 5 + Math.random() * 3,
                            delay: Math.random() * 2,
                            ease: "power1.in",
                            onComplete: () => {
                                positions[i*3] = (Math.random() - 0.5) * 200;
                                positions[i*3+1] = 300 + Math.random() * 100;
                                positions[i*3+2] = (Math.random() - 0.5) * 200;
                                droneGeometry.attributes.position.needsUpdate = true;
                            }
                        });
                    }
                }
                
                setTimeout(startCherryBlossomEffect, 8000);
            }, 5000);
        }
        
        // Hi·ªáu ·ª©ng 1 b√¥ng hoa anh ƒë√†o duy nh·∫•t
        function startCherryBlossomEffect() {
            startChaosMovement();
            
            setTimeout(() => {
                moveDronesToPositions(createCherryBlossomPositions(), 4, 1);
                
                gsap.to(droneMaterial, {
                    color: new THREE.Color(0xffb6c1),
                    size: 3,
                    duration: 2
                });
                
                const positions = droneGeometry.attributes.position.array;
                const originalPositions = new Float32Array(positions);
                
                const waveEffect = () => {
                    for (let i = 0; i < droneCount; i++) {
                        positions[i*3] = originalPositions[i*3] + (Math.random() - 0.5) * 1.5;
                        positions[i*3+1] = originalPositions[i*3+1] + (Math.random() - 0.5) * 1.5;
                    }
                    droneGeometry.attributes.position.needsUpdate = true;
                };
                
                const intervalId = setInterval(waveEffect, 100);
                
                setTimeout(() => {
                    clearInterval(intervalId);
                    startChaosMovement();
                    setTimeout(showAnniversaryDate, 5000);
                }, 8000);
            }, 5000);
        }
        
        // Hi·ªáu ·ª©ng hi·ªÉn th·ªã ng√†y k·ªâ ni·ªám
        function showAnniversaryDate() {
            // Hi·ªÉn th·ªã d√≤ng ch·ªØ 05.08.2025 ƒë∆°n gi·∫£n
            const datePositions = createDatePositions();
            moveDronesToPositions(datePositions, 3, 1);
            
            // M√†u s·∫Øc n·ªïi b·∫≠t (v√†ng cam)
            gsap.to(droneMaterial, {
                color: new THREE.Color(0xffcc00),
                size: 4,
                duration: 2
            });
            
            // Sau khi ch·ªØ hi·ªÉn th·ªã xong, m·ªõi b·∫Øt ƒë·∫ßu hi·ªáu ·ª©ng tr√°i tim bay v√†o
            setTimeout(() => {
                createHeartsFromEdges();
                
                // Sau khi hi·ªáu ·ª©ng tr√°i tim ho√†n th√†nh, hi·ªÉn th·ªã ch√¢n dung
                setTimeout(() => {
                    showPortrait();
                }, 15000); // 15 gi√¢y sau khi b·∫Øt ƒë·∫ßu hi·ªáu ·ª©ng tr√°i tim
            }, 3000);
        }
        
        // Hi·ªÉn th·ªã ch√¢n dung
        function showPortrait() {
            startChaosMovement();
            
            setTimeout(() => {
                // Di chuy·ªÉn drone t·∫°o th√†nh ch√¢n dung
                moveDronesToPositions(portraitPositions, 4, 1);
                
                // ƒê·ªïi m√†u sang m√†u ·∫•m √°p
                gsap.to(droneMaterial, {
                    color: new THREE.Color(0xff9966),
                    size: 3,
                    duration: 2
                });
                
                // Th√™m hi·ªáu ·ª©ng nh·∫•p nh√°y nh·∫π
                const intervalId = setInterval(() => {
                    gsap.to(droneMaterial, {
                        color: new THREE.Color(
                            0xff9966 + Math.random() * 0x333333
                        ),
                        duration: 1
                    });
                }, 2000);
                
                // Sau 15 gi√¢y, reset v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
                setTimeout(() => {
                    clearInterval(intervalId);
                    resetToInitialState();
                }, 15000);
            }, 5000);
        }
        
        // Reset v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
        function resetToInitialState() {
            const positions = droneGeometry.attributes.position.array;
            
            for (let i = 0; i < droneCount; i++) {
                gsap.to(positions, {
                    [i * 3]: initialPositions[i * 3],
                    [i * 3 + 1]: initialPositions[i * 3 + 1],
                    [i * 3 + 2]: initialPositions[i * 3 + 2],
                    duration: 3,
                    delay: Math.random() * 2,
                    ease: "power2.out"
                });
            }
            
            gsap.to(droneMaterial, {
                color: new THREE.Color(0xff3366),
                size: 3,
                duration: 2
            });
        }
        
        function startShow() {
            // B∆∞·ªõc 1: Hi·ªÉn th·ªã ch·ªØ "ANH Y√äU EM"
            moveDronesToPositions(createTextPositions(), 3, 2);
            gsap.to(droneMaterial, { color: new THREE.Color(0xff3366), duration: 2 });
            
            // B∆∞·ªõc 2: Sau 8 gi√¢y, reset v·ªÅ h·ªón lo·∫°n
            setTimeout(() => {
                startChaosMovement();
                
                // B∆∞·ªõc 3: Sau 5 gi√¢y h·ªón lo·∫°n, t·∫°o h√¨nh tr√°i tim l·ªõn
                setTimeout(() => {
                    moveDronesToPositions(createHeartPositions(), 4, 1.5);
                    gsap.to(droneMaterial, {
                        color: new THREE.Color(0xffb6c1),
                        duration: 2
                    });
                    
                    // B∆∞·ªõc 4: Sau 8 gi√¢y, chuy·ªÉn sang ch·∫ø ƒë·ªô h·ªón lo·∫°n l·∫ßn n·ªØa
                    setTimeout(() => {
                        startChaosMovement();
                        
                        // B∆∞·ªõc 5: Cu·ªëi c√πng, m·ªói drone bi·∫øn th√†nh tr√°i tim nh·ªè v√† bay l√™n
                        setTimeout(() => {
                            startHeartsFlying();
                            
                            // B∆∞·ªõc 6: Bay l√™n tr·ªùi t·∫°o th√†nh c√°c v√¨ sao v√† hi·ªáu ·ª©ng ch·ªØ Th√πy D∆∞∆°ng
                            setTimeout(thuyDuongFalling, 10000);
                        }, 5000);
                    }, 8000);
                }, 5000);
            }, 8000);
        }
        
        // X·ª≠ l√Ω thay ƒë·ªïi k√≠ch th∆∞·ªõc m√†n h√¨nh
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html> 